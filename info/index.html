<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>User Info Debug Page</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: #0b1020;
      color: #f5f5f5;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }

    .card {
      width: 100%;
      max-width: 980px;
      background: rgba(16, 22, 40, 0.96);
      border-radius: 16px;
      padding: 20px 22px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .card-header {
      margin-bottom: 12px;
    }

    .title {
      font-size: 1.4rem;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .subtitle {
      font-size: 0.9rem;
      color: #9fa7c3;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.75rem;
      padding: 3px 9px;
      border-radius: 999px;
      background: rgba(76, 175, 80, 0.08);
      color: #9de29d;
      border: 1px solid rgba(76, 175, 80, 0.35);
      margin-top: 6px;
    }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 10px 0 4px;
    }

    .btn {
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.04);
      color: #e5e7f4;
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 0.8rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.1s ease;
    }

    .btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.25);
      transform: translateY(-1px);
    }

    .btn:active {
      transform: translateY(0);
    }

    .section-label {
      display: inline-block;
      margin-top: 10px;
      margin-bottom: 4px;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #8891b0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      font-size: 0.9rem;
    }

    thead {
      background: rgba(255, 255, 255, 0.04);
    }

    th,
    td {
      padding: 8px 10px;
      text-align: left;
      vertical-align: top;
    }

    tbody tr:nth-child(even) {
      background: rgba(255, 255, 255, 0.02);
    }

    .key {
      width: 32%;
      font-weight: 600;
      color: #c4c9e5;
      word-break: break-word;
    }

    .value {
      width: 68%;
      color: #e5e7f4;
      word-break: break-word;
      white-space: pre-wrap;
    }

    .footer-note {
      margin-top: 10px;
      font-size: 0.75rem;
      color: #7b82a0;
    }

    @media (max-width: 600px) {
      .card {
        padding: 14px 12px;
      }

      .title {
        font-size: 1.1rem;
      }

      th,
      td {
        padding: 6px 6px;
      }
    }
  </style>
</head>
<body>
  <div class="card">
    <div class="card-header">
      <div class="title">Browser User Info (No-Permission Data)</div>
      <div class="subtitle">
        This page shows only data that JavaScript can read without asking for any explicit permission.
      </div>
      <div class="badge">
        <span>Live snapshot</span>
      </div>

      <div class="actions">
        <button class="btn" id="copyJsonBtn">Copy as JSON</button>
        <button class="btn" id="downloadJsonBtn">Download JSON</button>
        <button class="btn" id="refreshBtn">Refresh data</button>
      </div>
    </div>

    <span class="section-label">Collected fields</span>

    <table>
      <thead>
        <tr>
          <th>Field</th>
          <th>Value</th>
        </tr>
      </thead>
      <tbody id="infoBody">
        <!-- Filled by JS -->
      </tbody>
    </table>

    <div class="footer-note">
      Data is collected on each load without using location, camera, microphone, or any permission-based API.
    </div>
  </div>

  <script>
    var lastInfoArray = [];

    function safeGet(fn, fallback) {
      try {
        var value = fn();
        if (value === undefined || value === null || value === "") {
          return fallback;
        }
        return value;
      } catch (e) {
        return fallback;
      }
    }

    function getWebGLInfo() {
      try {
        var canvas = document.createElement("canvas");
        var gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
        if (!gl) {
          return {
            vendor: "Unavailable",
            renderer: "Unavailable",
            maxTextureSize: "Unavailable"
          };
        }

        var debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
        var vendor = "Hidden by browser";
        var renderer = "Hidden by browser";

        if (debugInfo) {
          vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) || "Unknown";
          renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) || "Unknown";
        }

        var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE) || "Unknown";

        return {
          vendor: vendor,
          renderer: renderer,
          maxTextureSize: maxTextureSize
        };
      } catch (e) {
        return {
          vendor: "Error",
          renderer: "Error",
          maxTextureSize: "Error"
        };
      }
    }

    async function getBatteryInfo() {
      try {
        if (!navigator.getBattery) {
          return {
            supported: false,
            level: "Not supported",
            charging: "Not supported",
            chargingTime: "Not supported",
            dischargingTime: "Not supported"
          };
        }

        var battery = await navigator.getBattery();

        return {
          supported: true,
          level: Math.round(battery.level * 100) + "%",
          charging: battery.charging ? "Yes" : "No",
          chargingTime: battery.chargingTime === Infinity ? "Infinity" : battery.chargingTime + " sec",
          dischargingTime: battery.dischargingTime === Infinity ? "Infinity" : battery.dischargingTime + " sec"
        };
      } catch (err) {
        return {
          supported: false,
          level: "Error",
          charging: "Error",
          chargingTime: "Error",
          dischargingTime: "Error"
        };
      }
    }

    async function getStorageEstimate() {
      try {
        if (!navigator.storage || !navigator.storage.estimate) {
          return {
            supported: false,
            quota: "Not supported",
            usage: "Not supported"
          };
        }

        var estimate = await navigator.storage.estimate();
        var quota = estimate.quota || 0;
        var usage = estimate.usage || 0;

        return {
          supported: true,
          quotaBytes: quota,
          usageBytes: usage,
          quotaMB: (quota / (1024 * 1024)).toFixed(2),
          usageMB: (usage / (1024 * 1024)).toFixed(2)
        };
      } catch (err) {
        return {
          supported: false,
          quota: "Error",
          usage: "Error"
        };
      }
    }

    async function getMediaDevicesInfo() {
      var result = {
        supported: false,
        total: "Not supported",
        kinds: {}
      };

      try {
        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
          return result;
        }

        var devices = await navigator.mediaDevices.enumerateDevices();
        result.supported = true;
        result.total = devices.length;
        var counts = {};

        devices.forEach(function (d) {
          if (!d.kind) {
            return;
          }
          if (!counts[d.kind]) {
            counts[d.kind] = 0;
          }
          counts[d.kind] += 1;
        });

        result.kinds = counts;
        return result;
      } catch (err) {
        return {
          supported: false,
          total: "Error",
          kinds: {}
        };
      }
    }

    function detectFonts() {
      var testFonts = [
        "Arial",
        "Verdana",
        "Times New Roman",
        "Courier New",
        "Georgia",
        "Tahoma",
        "Trebuchet MS",
        "Impact",
        "Comic Sans MS",
        "Helvetica"
      ];

      var baseFont = "sans-serif";
      var testString = "abcdefghijklmnopqrstuvwxyz0123456789";
      var fontSize = "72px";

      var canvas = document.createElement("canvas");
      var context = canvas.getContext("2d");

      function getWidth(fontFamily) {
        context.font = fontSize + " " + fontFamily;
        return context.measureText(testString).width;
      }

      var baseWidth = getWidth(baseFont);
      var availableFonts = [];

      testFonts.forEach(function (font) {
        var width = getWidth("'" + font + "', " + baseFont);
        if (Math.abs(width - baseWidth) > 0.1) {
          availableFonts.push(font);
        }
      });

      return availableFonts;
    }

    function getFeaturesSupport() {
      return {
        webgl: !!window.WebGLRenderingContext,
        webrtc: typeof RTCPeerConnection !== "undefined" ||
                typeof webkitRTCPeerConnection !== "undefined" ||
                typeof mozRTCPeerConnection !== "undefined",
        bluetooth: !!navigator.bluetooth,
        usb: !!navigator.usb,
        nfc: !!navigator.nfc,
        mediaDevices: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
        serviceWorker: "serviceWorker" in navigator,
        pushManager: "PushManager" in window,
        vibration: "vibrate" in navigator,
        clipboardRead: !!(navigator.clipboard && navigator.clipboard.readText),
        clipboardWrite: !!(navigator.clipboard && navigator.clipboard.writeText)
      };
    }

    async function getAudioInfo() {
      try {
        var AudioCtx = window.AudioContext || window.webkitAudioContext;
        if (!AudioCtx) {
          return {
            supported: false,
            sampleRate: "Not supported"
          };
        }

        var ctx = new AudioCtx();
        var sampleRate = ctx.sampleRate;
        ctx.close();

        return {
          supported: true,
          sampleRate: sampleRate
        };
      } catch (err) {
        return {
          supported: false,
          sampleRate: "Error"
        };
      }
    }

    function getPluginsInfo() {
      try {
        if (!navigator.plugins) {
          return {
            supported: false,
            plugins: []
          };
        }

        var list = [];
        for (var i = 0; i < navigator.plugins.length; i++) {
          var p = navigator.plugins[i];
          list.push(p.name);
        }

        return {
          supported: true,
          count: list.length,
          plugins: list
        };
      } catch (err) {
        return {
          supported: false,
          plugins: []
        };
      }
    }

    async function collectInfo() {
      var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection || null;
      var glInfo = getWebGLInfo();
      var features = getFeaturesSupport();
      var fonts = detectFonts();
      var plugins = getPluginsInfo();

      var darkMode = safeGet(function () {
        return window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "Dark" : "Light";
      }, "Not available");

      var reducedMotion = safeGet(function () {
        return window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches ? "Reduce" : "No preference";
      }, "Not available");

      var timezone = safeGet(function () {
        return Intl.DateTimeFormat().resolvedOptions().timeZone;
      }, "Not available");

      var timezoneOffset = new Date().getTimezoneOffset();

      var uptimeMs = performance && performance.now ? performance.now() : null;

      var batteryPromise = getBatteryInfo();
      var storagePromise = getStorageEstimate();
      var mediaDevicesPromise = getMediaDevicesInfo();
      var audioPromise = getAudioInfo();

      var results = await Promise.all([
        batteryPromise,
        storagePromise,
        mediaDevicesPromise,
        audioPromise
      ]);

      var battery = results[0];
      var storage = results[1];
      var mediaDevices = results[2];
      var audio = results[3];

      var data = [
        { key: "Browser userAgent", value: navigator.userAgent },
        { key: "Browser language", value: navigator.language },
        { key: "Browser languages list", value: (navigator.languages || []).join(", ") || "Not available" },
        { key: "Platform", value: navigator.platform || "Not available" },
        { key: "Cookies enabled", value: navigator.cookieEnabled },
        { key: "Do Not Track", value: navigator.doNotTrack || "Not specified" },

        { key: "CPU cores (hardwareConcurrency)", value: navigator.hardwareConcurrency || "Not supported" },
        { key: "Approx device memory (GB)", value: navigator.deviceMemory || "Not supported" },
        {
          key: "Touch support",
          value:
            ("maxTouchPoints" in navigator && navigator.maxTouchPoints > 0) || "ontouchstart" in window
              ? "Touch capable"
              : "No touch detected"
        },

        { key: "Screen size (width x height)", value: screen.width + " x " + screen.height },
        { key: "Available screen size", value: screen.availWidth + " x " + screen.availHeight },
        { key: "Color depth", value: screen.colorDepth || "Not available" },
        { key: "Pixel depth", value: screen.pixelDepth || "Not available" },
        { key: "Device pixel ratio", value: window.devicePixelRatio || 1 },

        { key: "Window inner size", value: window.innerWidth + " x " + window.innerHeight },
        { key: "Window outer size", value: window.outerWidth + " x " + window.outerHeight },
        { key: "Scroll position", value: window.scrollX + ", " + window.scrollY },

        {
          key: "Connection type",
          value: connection && connection.type ? connection.type : "Not supported or hidden"
        },
        {
          key: "Effective connection type",
          value: connection && connection.effectiveType ? connection.effectiveType : "Not supported"
        },
        {
          key: "Downlink (approx Mbps)",
          value: connection && connection.downlink ? connection.downlink : "Not supported"
        },
        {
          key: "Round-trip time (ms)",
          value: connection && connection.rtt ? connection.rtt : "Not supported"
        },
        {
          key: "Data saver enabled",
          value: connection && typeof connection.saveData === "boolean" ? connection.saveData : "Not supported"
        },

        { key: "Battery supported", value: battery.supported },
        { key: "Battery level", value: battery.level },
        { key: "Charging", value: battery.charging },
        { key: "Charging time", value: battery.chargingTime },
        { key: "Discharging time", value: battery.dischargingTime },

        {
          key: "Storage supported",
          value: storage.supported
        },
        {
          key: "Storage quota (MB)",
          value: storage.quotaMB !== undefined ? storage.quotaMB : "Not available"
        },
        {
          key: "Storage usage (MB)",
          value: storage.usageMB !== undefined ? storage.usageMB : "Not available"
        },

        {
          key: "Media devices supported",
          value: mediaDevices.supported
        },
        {
          key: "Media devices total",
          value: mediaDevices.total
        },
        {
          key: "Media devices by kind",
          value: JSON.stringify(mediaDevices.kinds)
        },

        {
          key: "Audio supported",
          value: audio.supported
        },
        {
          key: "Audio sample rate",
          value: audio.sampleRate
        },

        { key: "Time zone", value: timezone },
        { key: "Time zone offset (minutes)", value: timezoneOffset },
        { key: "Local time", value: new Date().toString() },

        { key: "Current URL", value: location.href },
        { key: "Referrer", value: document.referrer || "None" },

        { key: "localStorage support", value: typeof window.localStorage !== "undefined" },
        { key: "sessionStorage support", value: typeof window.sessionStorage !== "undefined" },
        { key: "IndexedDB support", value: typeof window.indexedDB !== "undefined" },

        { key: "WebGL vendor", value: glInfo.vendor },
        { key: "WebGL renderer", value: glInfo.renderer },
        { key: "WebGL max texture size", value: glInfo.maxTextureSize },

        { key: "Features support", value: JSON.stringify(features) },
        { key: "Available common fonts", value: fonts.length ? fonts.join(", ") : "Not detected" },

        { key: "Plugins supported", value: plugins.supported },
        {
          key: "Plugins count",
          value: plugins.supported ? plugins.count : "Not available"
        },
        {
          key: "Plugins list",
          value: plugins.supported ? plugins.plugins.join(", ") : "Not available"
        },

        { key: "Preferred color scheme", value: darkMode },
        { key: "Reduced motion preference", value: reducedMotion },

        {
          key: "Performance uptime (ms since load)",
          value: uptimeMs !== null ? uptimeMs.toFixed(2) : "Not available"
        }
      ];

      return data;
    }

    async function renderTable() {
      var infoBody = document.getElementById("infoBody");
      infoBody.innerHTML = "";
      var info = await collectInfo();
      lastInfoArray = info;

      info.forEach(function (item) {
        var tr = document.createElement("tr");

        var tdKey = document.createElement("td");
        tdKey.className = "key";
        tdKey.textContent = item.key;

        var tdValue = document.createElement("td");
        tdValue.className = "value";
        tdValue.textContent =
          typeof item.value === "object" ? JSON.stringify(item.value) : String(item.value);

        tr.appendChild(tdKey);
        tr.appendChild(tdValue);
        infoBody.appendChild(tr);
      });
    }

    function infoArrayToObject() {
      var obj = {};
      lastInfoArray.forEach(function (item) {
        obj[item.key] = item.value;
      });
      return obj;
    }

    async function handleCopyJson() {
      if (!lastInfoArray.length) {
        await renderTable();
      }
      var dataObj = infoArrayToObject();
      var json = JSON.stringify(dataObj, null, 2);

      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(json);
          alert("JSON copied to clipboard");
        } else {
          var temp = document.createElement("textarea");
          temp.value = json;
          document.body.appendChild(temp);
          temp.select();
          document.execCommand("copy");
          document.body.removeChild(temp);
          alert("JSON copied to clipboard");
        }
      } catch (e) {
        alert("Could not copy JSON");
      }
    }

    async function handleDownloadJson() {
      if (!lastInfoArray.length) {
        await renderTable();
      }
      var dataObj = infoArrayToObject();
      var json = JSON.stringify(dataObj, null, 2);

      var blob = new Blob([json], { type: "application/json" });
      var url = URL.createObjectURL(blob);
      var a = document.createElement("a");
      a.href = url;
      a.download = "user-info-debug.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    document.addEventListener("DOMContentLoaded", function () {
      renderTable();

      document.getElementById("copyJsonBtn").addEventListener("click", function () {
        handleCopyJson();
      });

      document.getElementById("downloadJsonBtn").addEventListener("click", function () {
        handleDownloadJson();
      });

      document.getElementById("refreshBtn").addEventListener("click", function () {
        renderTable();
      });
    });
  </script>
</body>
</html>
